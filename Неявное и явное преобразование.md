## Общая информация

Когда нам требуется преобразовать переменную одного типа в переменную другого типа, мы используем конструкции **явного и неявного** преобразований. 
## Неявное преобразование

**Неявное преобразование** происходит без использования отдельных методов, так как расширяющие преобразования от типа с меньшей разрядностью к типу с большей разрядностью **не вызывает потерю данных**:

>byte -> short -> int -> long -> decimal

>int -> double

>short -> float -> double 

>char -> int 

Обратите внимание также на то, что тип *char  возможно неявно преобразовать в int*, так как *char* хранит в себе целочисленное значение символьной кодировки

### Интересный пример неявного преобразования:

Еще одним примером неожиданного результата преобразования типов является ситуация, когда в арифметической операции используются два значения типа byte. В этом случае операнды типа byte неявно преобразуюся к типу int. А затем выполняется операция, дающая результат типа int. Следовательно, *результат выполнения операции, в которой участвуют два значения типа byte, будет иметь тип int*.

## Явное преобразование 

При явном же преобразовании есть несколько моментов, которые стоит отдельно обговорить.

### Переполнение типа

Например, *если мы хотим присвоить переменной определенного типа значение, выходящее за рамки диапазона значений этой переменной*, то мы сталкиваемся с таким понятием как **переполнение**.

Из определения переменной как именованной области памяти следует, что *у переменных разных типов количество ячеек, используемых для записи информации, отличается*. Такие **ячейки** называют **битами**, а **совокупности из 8 бит** называют **байтами**.

### Пример явного преобразования

Давайте посмотрим, что же происходит с информацией в этих ячейках при попытке явно преобразовать переменную типа с большим диапазоном значений (большим количеством ячеек) в переменную с их меньшим количеством.

> *short variableOne = 4510;*   (объявили переменную типа short, которая занимает два байта в памяти)

> *byte variableTwo = (byte)variableOne;*  (явное преобразование в тип byte, занимающий один байт памяти)

Что же произошло с точки зрения машинной логики? **Часть данных безвозвратно утеряна**, но давайте посмотрим что же осталось. Для этого переведем привычное нам число 4510 в двоичный код, понятный компьютеру:

00010001 10011110 - мы видим два байта по восемь бит каждый, занятые информацией.

**При операции явного преобразования в byte часть этой информации пропадет, а конкретно - старшие байты**. В данном случае это будет один байт, так как *разница между short и byte - один байт*.

Останется 10011110 - это число 158 в привычной нам десятичной системе счисления.

### Математическая аналогия

Математическим аналогом этих преобразований будет *операция вычисления **остатка** от деления **значения** исходной переменной **на диапазон значений** новой переменной*.

Диапазон значений переменной типа byte: от 0 до 255     (итого 256 значений)

**4510 % 256 = 158**